<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>LAP Verifier Core Tests</title>
        <style>
            body {
                font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI,
                    Roboto, Helvetica, Arial, sans-serif;
                padding: 16px;
                background: #0b1220;
                color: #e5e7eb;
            }
            .ok {
                color: #22c55e;
            }
            .fail {
                color: #ef4444;
            }
            pre {
                white-space: pre-wrap;
            }
        </style>
        <script type="module">
            import {
                verifyFragment,
                nowSecs as realNow,
                fetchRA as realFetchRA,
            } from "/js/la/verifier.core.js";
            import { schnorr as NobleSchnorr } from "/js/vendor/noble-secp256k1.js";
            // Use a deterministic in-test Schnorr stub so tests don't depend on external crypto bundles
            function bytesToHex(bytes) {
                return Array.from(bytes)
                    .map((b) => b.toString(16).padStart(2, "0"))
                    .join("");
            }
            const TestSchnorr = {
                async sign(msgU8, privHex) {
                    return `sig:${bytesToHex(msgU8)}:${privHex}`;
                },
                async getPublicKey(privHex) {
                    return `pub:${privHex}`;
                },
                async verify(sigHex, msgU8, pubHex) {
                    const msgHex = bytesToHex(msgU8);
                    if (!sigHex || !sigHex.startsWith(`sig:${msgHex}:`))
                        return false;
                    const priv = sigHex.slice(`sig:${msgHex}:`.length);
                    const derivedPub = `pub:${priv}`;
                    return derivedPub === pubHex;
                },
            };

            function deepMerge(target, source) {
                if (!source || typeof source !== "object") return target;
                for (const k of Object.keys(source)) {
                    const sv = source[k];
                    if (sv && typeof sv === "object" && !Array.isArray(sv)) {
                        target[k] = deepMerge(
                            target[k] ? { ...target[k] } : {},
                            sv
                        );
                    } else {
                        target[k] = sv;
                    }
                }
                return target;
            }

            function resolveNow(nowExpr, stapled) {
                if (typeof nowExpr === "number") return nowExpr;
                if (typeof nowExpr === "string") {
                    const m = /^(exp|iat)([+-])(\d+)$/.exec(nowExpr);
                    if (m) {
                        const base = Number(stapled.payload[m[1]]);
                        const delta = Number(m[3]);
                        return m[2] === "+" ? base + delta : base - delta;
                    }
                }
                return Math.floor(Date.now() / 1000);
            }

            function canonicalizePayloadForSignature(payload) {
                const order = [
                    "url",
                    "attestation_url",
                    "hash",
                    "etag",
                    "iat",
                    "exp",
                    "kid",
                ];
                const obj = {};
                for (const k of order) {
                    if (
                        Object.prototype.hasOwnProperty.call(payload || {}, k)
                    ) {
                        obj[k] = payload[k];
                    }
                }
                return JSON.stringify(obj);
            }

            async function signStapledInPlace(stapled, privHex) {
                const json = canonicalizePayloadForSignature(stapled.payload);
                const enc = new TextEncoder();
                const digest = await crypto.subtle.digest(
                    "SHA-256",
                    enc.encode(json)
                );
                const msg = new Uint8Array(digest);
                const sigHex = await TestSchnorr.sign(msg, privHex);
                const pubHex = await TestSchnorr.getPublicKey(privHex);
                stapled.sig = sigHex;
                stapled.resource_key = pubHex;
                return stapled;
            }

            const TEST_PRIV =
                "0000000000000000000000000000000000000000000000000000000000000001";

            async function runVector(vec) {
                const out = document.getElementById("out");
                const log = (ok, msg) => {
                    const div = document.createElement("div");
                    div.className = ok ? "ok" : "fail";
                    div.textContent = (ok ? "✔ " : "✖ ") + msg;
                    out.appendChild(div);
                };

                // Allow vectors to reference a pre-generated stapled RA fixture
                let stapled = vec.stapled;
                if (!stapled && typeof vec.stapledFromFixture === "string") {
                    try {
                        const res = await fetch(vec.stapledFromFixture, {
                            cache: "no-store",
                        });
                        if (res.ok) {
                            stapled = await res.json();
                        } else {
                            throw new Error(`HTTP ${res.status}`);
                        }
                    } catch (e) {
                        log(
                            false,
                            `${vec.id}: failed to load fixture ${
                                vec.stapledFromFixture
                            }: ${e && e.message ? e.message : String(e)}`
                        );
                        return;
                    }
                }
                if (!stapled) {
                    // Special case for LA_NO_ATTESTATION test - actually run verification with null
                    if (vec.expect && vec.expect.code === "LA_NO_ATTESTATION") {
                        const result = await verifyFragment({
                            stapled: null,
                            verifyBytes: async () => null,
                            fetchRAImpl: async () => null,
                            nowImpl: () => Math.floor(Date.now() / 1000),
                            policy: vec.policy || "strict",
                            skewSeconds: vec.skewSeconds || 120,
                            verifySigImpl: TestSchnorr,
                        });

                        const exp = vec.expect;
                        const ok =
                            result &&
                            result.ok === exp.ok &&
                            result.status === exp.status &&
                            result.code === exp.code;
                        if (ok) {
                            log(true, `${vec.id}: passed`);
                        } else {
                            log(
                                false,
                                `${vec.id}: expected ${JSON.stringify(
                                    exp
                                )}, got ${JSON.stringify(result)}`
                            );
                        }
                        return;
                    }
                    log(false, `${vec.id}: missing stapled attestation input`);
                    return;
                }
                const useTestSig = vec.useTestSig !== false; // default true; set false to use native noble + Go-signed RA
                if (useTestSig) {
                    // Sign the stapled attestation so signature validation passes under TestSchnorr
                    await signStapledInPlace(stapled, TEST_PRIV);
                    if (vec.sig === "invalid") {
                        // Replace the public key to break signature verification
                        const OTHER_PRIV =
                            "0000000000000000000000000000000000000000000000000000000000000002";
                        stapled.resource_key = await TestSchnorr.getPublicKey(
                            OTHER_PRIV
                        );
                    }
                }
                const live = deepMerge(
                    {
                        payload: { ...stapled.payload },
                        resource_key: stapled.resource_key,
                        sig: stapled.sig,
                    },
                    vec.liveOverrides || {}
                );
                const nowValue = resolveNow(vec.now, stapled);

                const verifyBytes = async () => {
                    if (vec.verifyBytes === "FORCE_MISMATCH")
                        return "hash mismatch";
                    return vec.verifyBytes === "ok" ? null : "bytes mismatch";
                };
                const fetchRAImpl = async (url) => {
                    if (vec.fetchRAImpl === "FORCE_FETCH_ERROR") {
                        throw new Error("fetch failed: 404");
                    }
                    return live;
                };
                const nowImpl = () => nowValue;

                const result = await verifyFragment({
                    stapled,
                    verifyBytes,
                    fetchRAImpl,
                    nowImpl,
                    policy: vec.policy || "strict",
                    skewSeconds:
                        typeof vec.skewSeconds === "number"
                            ? vec.skewSeconds
                            : 120,
                    lastKnownAt: vec.lastKnownAt || null,
                    verifySigImpl: useTestSig ? TestSchnorr : NobleSchnorr,
                });

                const exp = vec.expect || {};
                const ok =
                    result &&
                    result.ok === exp.ok &&
                    result.status === exp.status &&
                    result.code === exp.code;
                if (ok) {
                    log(true, `${vec.id}: passed`);
                } else {
                    log(
                        false,
                        `${vec.id}: expected ${JSON.stringify(
                            exp
                        )}, got ${JSON.stringify(result)}`
                    );
                }
            }

            async function run() {
                const out = document.getElementById("out");
                const log = (ok, msg) => {
                    const div = document.createElement("div");
                    div.className = ok ? "ok" : "fail";
                    div.textContent = (ok ? "✔ " : "✖ ") + msg;
                    out.appendChild(div);
                };
                try {
                    // Matrix-driven cases
                    const idxRes = await fetch(
                        "/tests/core/matrix.index.json",
                        {
                            cache: "no-store",
                        }
                    );
                    if (!idxRes.ok) {
                        log(
                            false,
                            `Failed to load matrix.index.json: HTTP ${idxRes.status}`
                        );
                        return;
                    }
                    const index = await idxRes.json();
                    const params = new URLSearchParams(window.location.search);
                    const filterPolicy = params.get("policy");
                    const filterCode = params.get("code");
                    const filterId = params.get("id");
                    const selected = index.cases.filter(
                        (c) =>
                            (!filterPolicy || c.policy === filterPolicy) &&
                            (!filterCode || c.code === filterCode) &&
                            (!filterId || c.id === filterId)
                    );
                    // Render a small index header for convenience
                    const hdr = document.createElement("div");
                    hdr.style.marginBottom = "12px";
                    hdr.style.opacity = "0.8";
                    hdr.textContent = `Cases: ${
                        selected.length || index.cases.length
                    }`;
                    out.appendChild(hdr);
                    if (selected.length === 0) {
                        log(true, "No filters provided; running all cases");
                    }
                    for (const c of selected.length ? selected : index.cases) {
                        try {
                            const vecRes = await fetch(c.path, {
                                cache: "no-store",
                            });
                            if (!vecRes.ok) {
                                log(
                                    false,
                                    `${c.id}: HTTP ${vecRes.status} for ${c.path}`
                                );
                                continue;
                            }
                            const vec = await vecRes.json();
                            await runVector(vec);
                        } catch (e) {
                            log(
                                false,
                                `${c.id}: load failed ${
                                    e && e.message ? e.message : String(e)
                                }`
                            );
                        }
                    }
                } catch (e) {
                    console.error("[tests] runner exception", e);
                    log(
                        false,
                        `Runner exception: ${
                            e && e.message ? e.message : String(e)
                        }`
                    );
                }
            }

            window.addEventListener("DOMContentLoaded", run);
        </script>
    </head>
    <body>
        <h1>LAP Verifier Core Tests</h1>
        <div id="out"></div>
    </body>
</html>
